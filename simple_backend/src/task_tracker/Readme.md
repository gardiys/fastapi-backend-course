### Хранение состояния
**Хранение состояния (state)** - это информация, которую приложение сохраняет и использует во время своей работы. В текущей реализации мы храним задачи в оперативной памяти в списке Python.

### Минусы хранения задач в оперативной памяти:
1. **Потеря данных при перезапуске**: Все задачи удаляются при выключении или перезагрузке сервера.
2. **Отсутствие персистентности**: Данные существуют только во время работы приложения.
3. **Ограничение масштабируемости**: При использовании нескольких экземпляров приложения (например, в кластере) каждый будет иметь свой собственный список задач.
4. **Проблемы с памятью**: При большом количестве задач может исчерпаться доступная оперативная память.

## После перехода на файл JSON

### Что улучшилось:
1. **Персистентность**: Данные сохраняются между перезапусками приложения.
2. **Простота реализации**: Не требуется сложная настройка базы данных.

### Избавились ли мы от хранения состояния?
Нет, мы не полностью избавились от состояния:
- Состояние теперь хранится в файле на диске, а не в памяти
- Приложение все еще зависит от локального файла
- Проблемы синхронизации между несколькими экземплярами остались

### Альтернативные способы хранения:
1. **Реляционные БД (PostgreSQL, MySQL)**
   - Преимущества: транзакции, надежность, масштабируемость
   - Недостатки: сложность настройки, overhead
   
2. **NoSQL (MongoDB, Redis)**
   - Преимущества: гибкость, производительность
   - Недостатки: сложность консистентности данных
   
3. **Облачные сервисы**
   - Преимущества: доступность, масштабируемость
   - Недостатки: зависимость от внешнего сервиса, задержки сети

### Состояние гонки

Состояние гонки (race condition) - это ситуация, когда результат операции зависит от последовательности выполнения нескольких потоков или процессов.

### Текущие проблемы:
1. **При использовании файла JSON**:
   - Одновременная запись от разных процессов может привести к повреждению данных
   - Нет гарантии атомарности операций

2. **При использовании облачного сервиса**:
   - Задержки сети могут привести к несогласованности данных
   - Одновременные запросы могут конфликтовать

### Возможные решения:
1. **Для локального файла**:
   - Использовать блокировки (file locks)
   - Перейти на БД с поддержкой транзакций

2. **Для облачного сервиса**:
   - Использовать версионирование данных
   - Применять optimistic concurrency control
   - Добавить механизм retry для неудачных операций

### Преимущества FastAPI:
1. Асинхронная обработка запросов
2. Автоматическая валидация данных через Pydantic
3. Интерактивная документация (Swagger UI)